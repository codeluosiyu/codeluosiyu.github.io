(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{347:function(t,n,s){},434:function(t,n,s){"use strict";s(347)},545:function(t,n,s){"use strict";s.r(n);s(434);var e=s(25),v=Object(e.a)({},(function(){var t=this,n=t.$createElement,s=t._self._c||n;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"_10-var、let-和-const-区别的实现原理是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_10-var、let-和-const-区别的实现原理是什么"}},[t._v("#")]),t._v(" "),s("H2Icon"),t._v("10.var、let 和 const 区别的实现原理是什么")],1),t._v(" "),s("p",[t._v("var 和 let 用以声明变量，const 用于声明只读的常量；")]),t._v(" "),s("p",[t._v("var 声明的变量，不存在块级作用域，在全局范围内都有效，")]),t._v(" "),s("p",[t._v("let 和 const声明的，只在它所在的代码块内有效；")]),t._v(" "),s("p",[t._v("let 和 const 不存在像 var 那样的 “变量提升” 现象，所以 var 定义变量可以先使用，后声明，而 let 和 const 只可先声明，后使用；")]),t._v(" "),s("p",[t._v("let 声明的变量存在暂时性死区，即只要块级作用域中存在 let，那么它所声明的变量就绑定了这个区域，不再受外部的影响。")]),t._v(" "),s("p",[t._v("let 不允许在相同作用域内，重复声明同一个变量；")]),t._v(" "),s("p",[t._v("const 在声明时必须初始化赋值，一旦声明，其声明的值就不允许改变，更不允许重复声明；如 const 声明了一个复合类型的常量，其存储的是一个引用地址，不允许改变的是这个地址，而对象本身是可变的。")]),t._v(" "),s("p",[s("strong",[t._v("变量与内存之间的关系，主要由三个部分组成：变量名 内存地址 内存空间")])]),t._v(" "),s("p",[t._v("JS 引擎在读取变量时，先找到变量绑定的内存地址，然后找到地址所指向的内存空间，最后读取其中的内容。当变量改变时，JS 引擎不会用新值覆盖之前旧值的内存空间（虽然从写代码的角度来看，确实像是被覆盖掉了），而是重新分配一个新的内存空间来存储新值，并将新的内存地址与变量进行绑定，JS 引擎会在合适的时机进行 GC，回收旧的内存空间。const 定义变量（常量）后，变量名与内存地址之间建立了一种不可变的绑定关系，阻隔变量地址被改变，当 const 定义的变量进行重新赋值时，根据前面的论述，JS 引擎会尝试重新分配新的内存空间，所以会被拒绝，便会抛出异常。")]),t._v(" "),s("RightMenu")],1)}),[],!1,null,null,null);n.default=v.exports}}]);